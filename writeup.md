# Pipeline
I loaded the images and made a copy of them, so later I can draw over them, then converted the images to grayscale so it is easier to execute color selection. The lanes on the road should appear brighter then the road itself. Then cut out the most interesting part of the picture where the lane should be, more or less, and after that I did a gaussian_blur, because it seemed canny edge detection behaves better after I blurred the image, and then found the lines with hough_lines. In the draw function I separated the right lane and left lane by their slope which you can do by taking the lines from hough_lines output and just calculate the slope with an easy method like ((y2 - y1) / (x2 - x1)), so I know if the result is > 0 then the line looks like a backslash "\" and if the result is < 0 then it looks like a slash "/". Calculated the right and left lane averages with np.mean and extrapolated the line using the y = mx + b equation, where I calculated m and b from the averaged out line, where m is the slope and then it's easy to rearrange the equation so I get b = y - m * x. Now that I have the line equation I just needed to calculate the two endpoints of the line. The bottom point is gonna be at the bottom of the picture, which means y = the picture's vertical size, and then I can calculate x = (y - b) / m. The top point is gonna be somewhere in the middle of the picture where it looks good and then just draw this line.

# Shortcomings
The line detection could detect other things as lines not only the lane.
There are some baked in coordinates that definitely wouldn't work in some pictures for example cutting out the region of interest and getting the color selection.
Right now we can only draw straight lines and extrapolate for the same Y coordinates even if there is no road there.

## Possible improvements
We can play around with the opencv parameters so it wont detect for example guard rails as lane lines.
At the beginning I didn't want to use color selection because if the lines on the road are darker (dirty), then it is possible for it to cut them out, so I'm sure that it is possible to remove that step, and just use the edge detection and line detection with some combination of parameters to detect the lanes, but this way was easier. We could detect curves too by using np.polyfit and np.Polynomial. We could find the initial lane lines somewhere at the bottom of the picture starting at the bottom middle and going outward on both sides and when we find the lanes we could follow that line. If there is no line at the bottom then we can decrease the Y coordinate until we find them, and there are some rules they must fulfill for example they can't cross and they have to be angled like an upside V, this way we can fix the region of interest baked in coordinates and we can fix the possible detection of other unwanted lines issue.